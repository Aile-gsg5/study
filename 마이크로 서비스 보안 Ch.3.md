# 암호화의 기초
- AWS 리소스와 데이터는 인가 또는 접근 통제 절차를 통해 비인가 접근을 제한하거나 민감한 데이터를 의도한 대상만 읽을 수 있도록 암호화해 격리할 수 있다
- 암호화는 악의적인 행위자가 민감한 데이터를 읽어 기밀성을 손상시키거나 적절한 접근 권한 없이 데이터를 변경해 무결성에 영향을 주는 등 잠재적 위협 행위로부터 데이터를 보호함
## 암호화의 간략한 개요
- 용어 정의
	- 평문 데이터: 사람이나 기계가 읽을 수 있는, 암호화하려는 파일이나 대상
	- 데이터 키(평문 데이터 키): 평문 데이터의 암호화 대상 정보를 암호화하는 데 사용하는 알고리즘에 대한 입력값을 의미하며 비밀번호와 유사
	- 암호문 데이터: AWS 시스템에 저장된 암호화한 데이터를 의미. 복호화하지 않고는 사람이나 기계가 읽을 수 없다
- 데이터 암호화를 위해 필요한 것
	- 평문 데이터
	- 데이터를 암호화하거나 복호화하는데 사용할 암호화키
- 대칭키 암호화: 암호화, 복호화 과정에서 사용하는 키가 동일
- 비대칭키 암호화: 암호화 과정과 복호화 과정에서 다른 키를 사용
## AWS에서 암호화의 중요성
- 심층 방어 개념: 잠재적인 위협에 대한 대응은 한 번의 강력한 방어보다 여러 번 중복해서 방어하는 것이 더 효과적
- AWS 환경은 물리적으로 격리되지 않아 저장소와 리소스를 다른 AWS 사용 고객과 공유하고 있어 민감 데이터를 보호하고 격리할 책임을 AWS는 갖고 있음
- 사용자만 접근할 수 있는 키로 민감한 데이터를 암호화하면 데이터를 AWS로 전달하는 과정에서 비인가 접근으로부터 데이터를 논리적으로 보호할 수 있음
- 물리적으로 통제 불가하여 암호화로 구현한 논리적 격리를 해야함
## 마이크로서비스 아키텍처에서 암호화의 중요성
- 출처별로 다른 암호화키로 데이터를 암호화하면 이점을 얻을 수 있다
## AWS에서의 암호화
- 미국 국립 표준 기술원 (NIST. National Institute of Standards and Technology)같은 정부기관은 종종 오픈소스 알고리즘을 표준화하며, 많은 규제 기관은 보안 정책을 공식화할 때 NIST의 전문성에 의존하는 경향이 있음
- AWS는 현존하는 표준화된 암호화 프로시저를 지원하는 도구들을 사용자에게 제공하고 있음
	- 공개키 공유, 비밀키 접근 통제, 키 교환 및 키 저장 등 암호화 절차와 관련한 모든 활동을 간단하고 안전하게 만듦
- AWS는 일반적인 암호화 과정에서 대칭키/비대칭키 암호화 알고리즘을 모두 지원함
## 키 기반 암호화의 보안 문제
- 암호화한 데이터는 악의적 행위자가 복호화키를 알기 전까지 안전한 것을 간주함
- 복호화 키를 보호하는 것이 매우 중요함
	- 복호화 키에 대한 모니터링을 하여 비정상적인 활동을 감지하는게 중요
	- 주기적으로 키를 교체하면 좋음
- 애플리케이션의 복잡성이 높을 수록 관리해야 할 암호화키가 늘어나고 이는 관리가 힘듦
## 비즈니스 문제
- KMS(Key Management Service)는 표준화된 인증과 접근 통제를 제공하고자 키를 둘러싼 일종의 포장지 역할을 함
- KMS를 사용해 데이터 암/복호화하는 절차
	![[Pasted image 20240519160803.png]]
## AWS KMS
- 키를 보호하기 위한 방법
	- 과거에는 하드웨어 보안 모듈(HSM, Hardware Security Module) 구입
	- KMS 사용
- AWS가 암호화키를 보호하고자 제공하는 도구모음으로 AWS 공동 책임 모델의 일부분으로 AWS에서 관리하고 보호하는 HSM의 지원을 받음
- 암호화, 복호화 또는 단순 접근 등 키를 사용해 수행한 모든 작업에 대한 로그를 저장하고 감사 추적을 할 수 있다
- AES-256 암호화 알고리즘으로 작은 크기의 바이너리 데이터를 암호화함
- 고객 마스터키(CMK, Customer Master Keys)를 쉽게 생성, 관리, 통제할 수 있는 관리형 서비스
- 장점
	- CMK를 보관할 수 있는 안전하고 내구성 있는 장소
	- CMK에 대한 접근 통제
	- CMK의 고가용성
### CMK를 사용한 기본 암호화
- 데이터의 크기가 4KB 미만의 작은 크기라면 KMS는 AES-256 알고리즘으로 직접 암호화하거나 복호화할 수 있다
- 4KB 이상의 데이터를 암호화하는 방법은 봉투 암호화 절에서 설명
- 프로세스는 두 유형의 암호화 모두 동일
	- 1. 서비스 A/B가 AWS 설정상 이미 인증된 상태로 가정. CMK를 AWS KMS 내에 생성하고 A/B의 접근을 허용
	- 2. 서비스 A는 B로 보내려는 데이터를 암호화하기로 결정하여 KMS에 암호화 요청
	- 3. KMS는 서비스 A가 신뢰하는 인증 공급자에게 이미 인증을 받았고 키 K에 접근할 수 있는 권한이 있음을 알고 있어, 데이터를 키 K로 암호화한 후 암호문을 응답으로 전송
	- 4. 서비스 A는 암호문을 서비스 B로 전송
	- 5. 서비스 B는 KMS에게 데이터 복호화 요청
	- 6. KMS는 서비스 B가 신뢰하는 인증 공급자에게 이미 인증을 받았고 키 K에 접근할 수 있는 권한이 있음을 알고 있어, 암호화된 데이터를 키 K로 복호화하여 평문 형태로 응답으로 전송
- 암호화 프로세스의 중요 측면
	- 공격자는 CMK가 없으면 데이터를 복호화할 수 없기 때문에 CMK가 비인가 접근으로부터 안전한 상태라면 민감 데이터는 안전한 것으로 간주
	- CMK에 대한 접근 권한을 서비스에 부여한 경우 해당 서비스는 CMK에 접근해 암호문을 복호화 가능
- AES-256 알고리즘과 키 공간
	- 키 공간(keyspace)는 해당 알고리즘으로 암호화하는 과정에서 키가 가질 수 있는 가능한 값 범위
	- 더 크고 랜덤한 키 공간을 가진 알고리즘일수록 무차별 대입 공격으로부터 안전
- KMS 기본 암호화는 매우 작은 데이터 모음이나 처리량 및 지연이 문제되지 않는 극히 기본적인 암호화 상황에서만 사용할 수 있어 대부분의 경우 봉투 암호화를 사용
	- 봉투 암호화는 KSM가 제공하는 기본 암호화 서비스를 기반으로 하고 있음
- KMS는 리전 내 동일 계정의 모든 서비스가 공유하는 계정 단위의 처리량 제한이 있어 처리량 제한 초과 조심
- AWS는 내부적으로 FIPS 140-2 인증(NIST에서 개발한 암호화 모듈 유효성 검사 인증 요소)을 받은 HSM을 사용하여 마스터키를 생성하고 보호함
- HSM의 보안은 AWS가 책임
### 봉투 암호화
- 암호화 프로세스
	- 데이터 키를 사용해 대용량 데이터 객체를 암호화
	- CMK를 사용해 데이터 키를 암호화하고 암호화한 데이터 키를 암호문 데이터와 함께 저장한 다음 평문 데이터 키를 삭제
- 봉투 암호화는 데이터 키를 암호화해 포함하는 부가적인 단계를 추가한 다음 데이터 키를 사용해 평문 데이터를 암호화한다
- 암호화된 데이터 키를 복호화하는 마스터키를 갖고 있는 경우 중앙 집중식 키 관리 서버를 호출하지 않고도 동일한 마이크로서비스 내에서 모든 데이터를 해독할 수 있다
- 기본 암호화와 봉투 암호화 차이
	- 기본 암호화: 암호화된 페이로드를 복호화한 직후 평문 데이터 얻음
	- 봉투 암호화: 첫 단계에서 평문 데이터 키를 얻지만 데이터는 여전히 암호화된 상태이므로 이를 복호화하려면 평문 데이터 키를 사용해야 함
	- 즉, 봉투 암호화는 평문 데이터를 얻고자 추가 단계가 있는 것이 유일한 차이점
	![[Pasted image 20240519214845.png]]
- 암호화 프로세스의 2가지 웅요 측면
	- 공격자는 CMK가 없으면 암호화된 데이터를 복호화하는 데 필요한 데이터 키를 복호화할 수 없기 때문에 CMK가 비인가 접근으로부터 안전한 상태라면 민감 데이터는 안전한 것으로 간주
	- CMK에 대한 접근 서비스에 허용하면 CMK에 대한 접근을 통해 서비스 암호문을 복호화하는 데 사용할 수 있는 암호화된 데이터 키를 복호화할 수 있으므로 서비스는 암호화된 암호문을 복호화 가능
- 기본 암호화는 4KB 제한이 있어 테이블의 개별 행을 암호화하거나 복호화하려면 CMK를 수백만번 호출할 가능성이 높아 KMS는 여러 번 호출하는 단계가 추가됨에 따라 암호화로 인해 발생하는 지연시간이 크게 증가함
- 봉투 암호화는 우선 데이터 암호화키(DEK, Data Encryption Key)를 만든 다음 해당 키를 사용해 전체 테이블을 암호화한다
- DEK는 암호화를 수행하는 앱의 메모리에 저장할 수도 있고 데이터 암호화 프로세스를 완료하면 KMS에서 암호화 함수를 호출해 CMK로 DEK를 암호화할 수 있다
	- 데이터키를 메모리 내에 임시 저장(캐싱)해 사용하면 효율성이 높아짐
	- 이에 따라 테이블 행수에 비례해 암호화 과정 지연이 증가하지 않게 됨
### 봉투 암호화 부연 설명
- 봉투 암호화 프로세스 단계
	- 1. KMS를 호출해 평문 데이터 키와 CMK로 암호화한 데이터 키를 생성 (한 번의 호출로 두 키를 모두 획득 가능)
	- 2. 단계 1에서 획득한 평문 데이터 키로 평문 데이터를 암호화
	- 3. 평문 데이터 키 삭제
	- 4. 네트워크를 통해 암호화된 데이터 키와 암호화된 이진 데이터를 수신측 서비스에 전송
	- 5. 암호화된 데이터 키를 가져온 후 KMS를 사용해 데이터 키를 복호화한다
	- 6. 메모리에 있는 평문 데이터 키를 사용해 암호화된 이진 데이터를 복호화한다
- 봉투 암호화 방식으로 얻는 통제
	- 데이터 저장소와 키 저장소를 분리
	- 네트워크로 전송한 암호화 데이터는 평문 데이터 키 없이는 쓸모없는 값이므로 데이터가 유출되더라도 안전.
	- 암호화된 데이터를 로컬에서 사용하여 데이터를 반복적으로 암호화하거나 복호화한다면 평문 데이터 키를 메모리에 임시 저장해 전체 프로세스를 빠르게 수행 가능
	- CMK로 데이터 키만 암호화하기 때문에 KMS 암호화 프로세스 용량 제한의 영향 범위에서 제외
- CLI: `aws kms generate-data-key --key-id <key ID> --key-spec ASE_256`
	- 이를 통해 얻은 평문 데이터 키(plaintext)를 사용해 평문 이진 데이터를 암호화 가능
	- 암호화된 이진 데이터와 함께 저장하거나 전송할 수 있는 암호화된 데이터 키(CiphertextBlob)를 반환
## 보안과 AWS KMS
- KMS를 활용해 마이크로서비스 아키텍처의 데이터와 정보를 보호하는 방법을 설명
### KMS 콘텍스트 및 인증 데이터
- 추가 인증 데이터(AAD, Additional Authenticated Data): 암호화에서 일반적으로 사용되는 공통 보안 메커니즘
	- 비밀로 취급하지 않음
	- 암호화된 데이터의 무결성과 신뢰성을 확인하고자 사용함
	- 암호문을 복호화하는 과정에서 필요하기 때문에 암호화된 데이터와 연결(binding)하지만 추가 인증 데이터를 암호문의 일부로 포함하진 않는다
- 튜플(tuple): 설명자(key)와 설명자에 대한 값을 포함해야 하고 암호화 과정에서 사용한 콘텍스트(키와 값)는 복호화 과정에서 다시 사용할 수 있어야함
- 대칭 유형의 CMK를 사용하는 KMS 암호화 작업은 인증 과정을 지원할 목적으로 추가 인증 데이터 역할을 하는 키/값 형태의 암호화 콘텍스트를 허용
	- 이는 비밀로 취급할 필요 없음
	- 콘텍스트 정보는 CloudTrail로그 내에서 평문으로 표시됨
### 키 정책
- CMK로의 접근 통제할 수 있어야 함
- CMK는 리소스 기반 정책을 사용해 접근 통제 가능
- CMK 생성 과정에서 키 정책을 명시적으로 지정하지 않으면 AWS는 root 사용자에게 CMK에 대한 전체 접근 권한을 부여하는 단일 정책 명령문으로 default 키 정책을 생성함
## Grants와 ViaService
- 암호화키에 접근하는 과정에 더 세분화된 접근 통제가 필요한 상황
- KMS grants에서는 보안을 손상시키지 않으면서 세분화된 수준의 접근 통제를 달성할 수 있도록 AWS에서 제공하는 2개의 도구 소개
### KMS grants
- KMS 키에 대한 접근 통제와 모니터링을 활성화하는 하나의 방법
- CMK(K)를 이용하여 암호/복호화하는 완전한 접근 권한을 가진 서비스 A가 서비스 B에서 일시적으로 K에 접근하고 사용할 수 있게 허용하고 싶은 경우 -> KMS grants가 필요한 시점
- grants는 CMK 단위로 적용하고 필요한 경우 계정 단위로 확장할 수 있다
- grants는 최종 일관성 원칙에 의존한다는 점에서 유의. KMS 키에 대한 grant를 만들거나 폐기해도 즉시 적용되지 않을 수 있음
- CLI: `aws kms create-grant --key-id <grant 생성하려는 key ID> --grantee-principal <grant를 수신할 권한 주체의 ARN> --operations Decrypt`
- 제약 조건(Constraints)을 적용하면 더 세분화된 권한 가질 수 있음
### KMS ViaService
- grants와 유사하게 키 정책의 ViaService 조건은 도메인 보안 인프라를 손상시키지 않고 외부 서비스가 키에 접근할 수 있게 하는 또 다른 도구
- 지정한 AWS 서비스만 CMK를 사용할 수 있도록 제한함
	- 허용/거부 정책을 모두 지원함. 특정 리소스에서만 허용/거부
## CMK와 CMK의 구성 요소 및 지원되는 작업
- CMK 구성요소
	- 키 메타데이터
		- 키를 식별하고 설명하는 데 도움을 주는 키의 속성.
		- 키 ID, 키 ARN, 키 태그 등
	- 키 별칭
		- 알아보기 쉽게 부여한 별도 이름. 앱 내에서 CMK 대신 사용 가능
	- 키 구성 요소
		- 실제 키를 구성하는 암호화 데이터를 의미로 암호 지식이 담겨 있다
		- 데이터를 암호화하거나 복호화하는 역할을 담담
### 키 구성 요소 가져오기
- KMS는 키와 별개로 키 구성 요소를 생성해 유지하며 새로운 CMK를 생성하면 KMS는 키 구성 요소와 관련 메타데이터를 HSM에 저장함
- AWS 고객이 소유한 키 구성 요소를 KMS로 가져올 수 있는 기능 제공
	- 규제 준수 목적으로 키 수명주기를 통제 가능해짐
	- 실수로 인한 삭제를 방지하고자 키를 즉시 삭제할 수 없게 한 KMS 제약을 해결
- 키 구성 요소는 콘솔뿐만 아니라 API로도 가져올 수 있다
### CMK 유형
- AWS 관리형 CMK
	- AWS 고객이 소유하지만 AWS에서 관리함
- 고객 관리형 CMK
	- AWS 고객의 키 관리가 필요. 대부분의 AWS 서비스를 지원할 수 있으나 공동 책임 모델에서 벗어나는 영역에 대한 특정 책임이 발생
- 키 구성 요소를 가져와 생성한 고객 관리형 CMK
	- 고객 관리형 CMK 하위 유형에 가까우나 AWS 고객 자신의 키 구성 요소를 가져오기 때문에 키 관리 프로세스와 수명 주기를 훨씬 더 효과적으로 통제할 수 있음
### 자동 키 교체
- 키 노출은 모든 보안 시스템이 직면한 큰 문제
- 키를 교체하면 키가 안전해짐
- PCI DSS(Payment Card Industry Data Security Standard)같은 일부 산업군의 표준에서는 정기적 키 교체를 요구함
- 키 교체는 암호화 과정에서 사용하는 배킹(backing)키 구성 요소를 변경하는 것을 의미
- CMK의 자동 키 교체 활성화
	- 매년 고객 관리형 CMK를 새로운 암호화 구성 요소로 자동 갱신
	- KMS는 사용자가 CMK를 삭제할 때까지 이전 버전의 CMK 암호화 구성 요소를 유지함
- KMS는 비활성화됐거나 삭제 대기 중인 키를 제외한 AWS 관리형 CMK를 1095일마다 교체함
	- 선택적으로 고객 관리형 CMK는 365일마다 교체 가능
### 수동 키 교체
- 키 교체를 더 세부적으로 통제하려면 자동 키 교체 대신 새로운 CMK 생성하는 방법이 있음
- 새로 생성한 CMK는 별도의 논리적 리소스이기 때문에 CMK에 대한 모든 참조 변경해야함
	- 앱에서는 별칭으로 CMK 참조하는 것이 좋음
### CMK 삭제
- CMK에는 리소스를 삭제할 수 있는 영역이 있어서 주의 필요
- CMK를 즉시 완전하게 삭제할 수 없는 CMK 유형이 있음
	- CMK를 삭제하면 해당 키를 사용해 암호화한 모든 리소스와 데이터는 영원히 복호화 불가능
	- CMK 삭제 예약을 취소할 수 있는 필수 대기 기간을 제공함 (7~30일)
## 리전과 KMS
- KMS가 리전별로 관리해야 하는 서비스인 것이 일반적으로 문제가 되진 않으나 2가지 특이 상황 존재
	- KMS로 지원되는 글로벌한 복제 서비스를 운영하고 있는 경우
		- 글로벌 복제 시 동일한 키 사용이 불가함으로 암호화 비용이 발생하는 교차 리전 통신을 포함할 수 있음
	- 규제 준수를 위해 데이터를 지리적으로 격리해야하는 경우
		- AWS는 사용자가 데이터를 저장한 지역과 동일한 리전 내 키를 사용해야함
### 비용, 복잡성, 규제 고려
- KMS는 자체 HSM 관리에 대한 휼륭한 대안을 제공하지만 KMS에 의존하는 시스템 설계 시 고려해야하는 몇 가지 절충안 존재
	- KMS 비용
		- 사용자는 KMS에 있는 CMK별로 정해진 요금 지불
		- CMK를 대상으로 한 모든 요청에 부가되는 요청당 요금
- CMK에 관한 작업은 AWS 계정 단위의 처리량 제한도 받음
	- 제한 받는 API 호출에는 암호화, 복호화, grants 생성 또는 CMK에 관한 다른 모든 작업에 대한 호출을 포함함
- KMS는 누구도 평문 키를 검색할 수 없게 설계됨
	- PCI-DSS level1, HIPPA, FIPS 104-2 level2 표준을 준수함
- KMS 펌웨어 업데이트는 매우 강력하고 제한적인 접근 통제를 받음
## 비대칭 암호화와 KMS
- 단일 키가 아닌 고유한 결합으로 서로 연결된 공개키와 개인키 등 2개의 키가 존재
- 공개키
	- 민감하지 않으면서 공개 가능한 데이터로 널리 사용 가능하고 자유롭게 배포됨
- 개인키
	- 비밀 값으로 키를 소유한 서비스 외부로 공유해서는 안됨
- AWS는 두 용도로 비대칭키 암호화 사용 가능
	- 암호화 및 복호화
	- 디지털 서명
### 암호화와 복호화
- 공개키로 평문을 암호화하고 대응하는 개인키로 복호화
- 비대칭 암호화 이점
	- 개인키를 사용해서만 데이터 복호화 가능하므로 의도한 수신 측만 암호문 복호화할 수 있음이 보장됨
	- 키 교환 없이 안전한 통신 채널 유지
- 비대칭 알고리즘 데이터 전송 측 절차
	- 1. 수신측의 공개키를 검색 및 획득
	- 2. 공개키를 사용해 민감 데이터 암호화
	- 3. 암호화된 암호문을 의도한 수신 측에 전송
	- 4. 공격자가 암호문에 접근하더라도 평문 읽기는 불가능
	- 5. 하지만 서비스 A는 개인키 A에 접근 가능하여 암호문 복호화 가능
- 중간자 공격이 불가능하고 키를 교환하지 않아 수신 측과 발신 측의 결합도가 낮음

## 디지털 서명(서명과 검증)
- 공개키와 개인키를 반대로 사용 (공개키로 복호화, 개인키로 암호화)
- 단계
	- 1. 서비스 A가 공개키를 모든 외부 관련자에게 전달
	- 2. 외부 서비스에 전송할 데이터에 디지털 서명하도록 KMS에 요청
	- 3. KMS는 서비스 A를 식별하고 개인키 A로 디지털 서명한 암호화된 데이터를 응답
	- 4. 서비스 A는 모든 외부 서비스에게 데이터를 전송
	- 5. 공개키 A로 단계 4에서 전송받은 데이터 복호화
	- 6. 공개키 A로 데이터 복호하 가능하여 외부 서비스는 데이터의 출처가 서비스 A임을 확신
	- 7. 공격자는 서비스 A인 것처럼 외부 서비스에 데이터를 보내더라도 공격자는 KMS 인증을 통과할 수 없어 개인키 A에 접근 불가
	- 8. 공격자는 개인키 A에 접근할수 없어 공개키 A로 복호화할 수 있는 데이터를 생성할 수 없어 외부 서비스의 신뢰를 얻을 수 없음
- 비대칭 암호화에 사용하는 일반적인 알고리즘은 RSA(Rivest-Shamir-Adleman)
## 도메인 주도 설계와 AWS KMS
- 도메인 설계에 맞게 암호화 전략을 모듈화하는 방법
- 암호화 관련 설계 고려 사항
	- 가능하면 봉투 암호화 사용하고 CMK는 데이터 키를 암호/복호화하는데만 사용
	- CMK 재사용 금지
	- 서로 통신하게 설계된 서비스만 키에 접근할 수 있도록 CMK 접근을 최소한으로 제한
	- 데이터 키를 로컬에 임시저장하지 않도록
	- KMS 콘텍스트를 사용해 부가적인 인증 수단 추가
	- 최소 권한의 원칙을 적용한 IAM 정책으로 AWS 키에 대한 접근을 제함
### 콘텍스트 경계와 암호화
- 암호화가 서비스 핵심은 아니지만 다양한 콘텍스트의 다양한 모듈에 걸쳐 존재하는 경우가 많고 암호화가 컨텍스트 경계를 넘어서면 기존 서비스 경계를 기반으로 한 모듈화 형태로 암호화 구현이 불가능함을 의미
- CMK가 어떤 경계 콘텍스트에 있어야 하는지에 대한 고민은 중요함
## 계정과 CMK 공유
- 서비스 콘텍스트의 자유를 위한다면 도메인마다 다른 계정을 사용하는 것이 좋음
- AWS는 계정 간 키를 공유할 수 있음
## KMS와 네트워크 고려 사항
- KMS는 관리형 서비스로 중앙 집중화한 클라우드 network에 완전히 위치해 새로운 문제를 만듦
- 개별 서비스에서 KMS와 연결할 수 있는 기능이 필요
	- 인터넷에 연결되지 않은 서비스의 인터넷 연결이 필요해 보안 위험이 증가
	- VPC 엔드포인트로 해결 가능
## KMS grants 재논의
- 매우 특정한 작업을 수행해야 하는 경우를 제외하고 아무도 키에 접근할 수 없어야 하는 것이 당연하고 이건 grants와 도메인 설계가 부합하는 조직의 교과서적인 예
- grants를 사용하면 일시적으로 외부 콘텍스트에 키를 공개하지 않아도 키에 대한 접근을 통제할 수 있음
## KMS 계정과 토폴로지: 통합
- 여러 계정에서 CMK 사용에 대한 2가지 옵션
	- CMK를 경계 콘텍스트 내에 포함하여 CMK는 도메인을 포함한 AWS 계정으 다른 서비스와 함께 유지됨
	- CMK를 독립적 엔터티로 취급해 별도의 AWS 계정에 포함함
### 옵션 1: 경계 콘텍스트 내에 CMK 포함
- AWS 계정와 경계 콘텍스트가 1:1 관계여서 개별 도메인을 더욱 쉽게 보호할 수 있음
- 도메인간 통신과 데이터 공유 문제가 있음
- KMS grants를 사용해 도메인 간 접근을 임시로 허용 가능
- 도메인을 깔끔히 분리할 수 있는 이점 존재
- 단점은 grants에 대한 대기 시간을 발생시키는 콘텍스트 간 통신에 복잡성이 추가됨
### 옵션 2: 전용 계정을 생성해 CMK 보유
- 이 계정은 모든 도메인과 서비스의 CMK를 보유한다.
- 전용 계정을 생성해 CMK를 보유하면 보안 인프라의 일부를 도메인 로직에서 인프라 계정으로 옮길 수 있는 분명한 이점
- KMS grants나 grants와 관련한 복잡성 없이 데이터에 대한 접근 세분화 허용 가능
- 명확한 보안 정책이 없는 경우 문제 될 수 있음
## AWS 시크릿 매니저
- 비밀번호, 자격증명 또는 토큰과 같은 secrets를 안전하게 유지하기 위한 AWS 서비스
- 중앙 집중식 저장소처럼 보이지만 분리된 상태를 유지하고 모든 비밀 값에 대한 우수한 접근 통제를 제공함
### 시크릿 매니저의 작동 방식
- 프로세스
	- 1. 서비스 A는 AWS 시크릿 매니저에 비밀번호 요청
	- 2. 시크릿 매니저는 서비스 A 및 비밀번호 요청 시 사용한 역할 인지 가능
	- 3. 시크릿 매니저는 자신의 저장소에 암호화된 비밀번호를 갖고 있어 KMS에 복호화 요청
	- 4. KMS는 시크릿 매니저가 서비스 A에게 제공하고자 요청한 경우에만 비밀번호 복호화하도록 지시하기 때문에 다른 서비스는 비밀번호에 접근 불가
	- 5. 단계 4에서 복호화한 비밀번호를 서비스 A에 전달하고 서비스 A는 DB와 연결 가능해짐
- 시크릿 매니저를 사용해 달성한 결과
	- 실행 중인 microservice 앱이 있음
	- 외부 엔터티가 AWS 역할로 사용자를 식별할 수 있도록 MS에 역할을 연결
	- 비밀 값을 가져오고자 시크릿 매니저 호출. IAM 정책 및 암호화된 값이 접근 통제를 처리
	- 가져온 비밀 값으로 자격증명 기반 인증이 필요한 데이터베이스나 기타 외부 리소스 호출
- 시크릿 매니저는 다양한 규제 표준을 완벽하게 준수하며 보안과 운영 효 율성 모두를 향상시킬 수 있는 서비스
### AWS 시크릿 매니저의 비밀 값 보호
- 시크릿 매니저는 데이터 키를 암호화해 비밀 값의 메타데이터로 저장함